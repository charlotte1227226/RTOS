# 棧(Stack)的概念

**多工／多執行緒系統** 中，**每個任務（或執行緒）都有自己專屬的呼叫堆疊（stack）**，用來存放該任務的函式呼叫框架（call frames）、參數、返回位址、區域變數……等執行上下文（context）。

---

1. **（task\_A 的 stack）**

   * task\_A標記了 `a`、`b`、`c`，代表 task\_A 在某個函式裡的**區域變數**。
   * 當 task\_A 呼叫函式時，這些變數──連同返回位址(返回位址:執行完後的下一行指令)、傳入參數──都會被推（push）到它自己的 stack 裡。

2. **（task\_B 的 stack）**

   * task\_B畫了 `f1`、`f2`、`f3`，代表 task\_B 正在呼叫的三層函式──第一層進去時壓入 `f1`，再呼叫下一層壓入 `f2`，再下一層壓入 `f3`。
   * 每次函式回傳，就會把對應的框架從 stack 頂端彈（pop）出來，恢復到呼叫它之前的狀態。

3. **為什麼要「每個任務都要自己的 stack」？**

   * **獨立性**：避免不同任務互相覆寫對方的區域變數或呼叫框架。
   * **並行切換**：作業系統在進行任務切換（context switch）時，只要記住這個任務的 stack pointer，就能下次從**完全相同**的執行點繼續。

影片字幕說的「所以說每個電路都有自己的帳」，就是在比喻──每條「執行迴路」（或每個任務）都有自己專屬的「帳本」（stack），記錄它的執行歷史和臨時資料，互不干擾。



---
在計算機科學裡，「棧（Stack）」是一種\*\*後進先出（LIFO，Last‑In‑First‑Out）\*\*的抽象資料結構，其核心概念和操作可以用生活中的「疊盤子」或「訂書機釘書針」來類比：

1. **結構與儲存**

   * 棧被想像成一疊元素，由底部（底端）和頂部（頂端）組成。
   * 新加入的元素總是放在頂端；要取出元素，也只能從頂端進行。

2. **基本操作**

   * **Push（入棧）**：將一個元素放到棧頂。例如：把一張新卡片放到最上面。
   * **Pop（出棧）**：從棧頂移除並回傳元素。例如：從最上面拿走一張卡片。
   * **Top or Peek（窺視棧頂）**：查看棧頂元素但不移除。例如：看看最上面的卡片是什麼。
   * **IsEmpty（判空）**：檢查棧裡是否還有元素。

3. **特性**

   * **後進先出**：最後 `Push` 的元素最先 `Pop`。
   * **存取受限**：只能在一端（頂端）進行存取，無法隨意從中間或底部抽取。

4. **用途舉例**

   * **函式呼叫棧（Call Stack）**：程式執行時，每呼叫一個函式就把返回位址和區域變數「入棧」，函式執行完畢再「出棧」返回呼叫點。這確保了函式能夠正確地以後進先出的順序完成。
   * **中序轉後序運算**：在編譯器或計算器裡，用棧來處理運算子優先順序。
   * **深度優先搜尋（DFS）**：圖或樹的 DFS 演算法可用棧來記錄節點順序。
   * **括號配對**：檢查字串裡的括號是否成對，透過棧依次入棧左括號，遇到右括號則出棧檢查。

5. **範例程式（C 語言）**

   ```c
   #define MAX 100

   typedef struct {
       int data[MAX];
       int top;  // 棧頂索引，-1 表示空棧
   } Stack;

   void init(Stack *s) {
       s->top = -1;
   }

   int is_empty(Stack *s) {
       return s->top == -1;
   }

   int is_full(Stack *s) {
       return s->top == MAX - 1;
   }

   // 入棧
   int push(Stack *s, int x) {
       if (is_full(s)) return 0; // 失敗
       s->data[++s->top] = x;
       return 1; // 成功
   }

   // 出棧
   int pop(Stack *s, int *x) {
       if (is_empty(s)) return 0; // 失敗
       *x = s->data[s->top--];
       return 1; // 成功
   }
   ```

---

> **小結**：棧是一種受限的線性結構，只能在頂端做新增與刪除操作，並且遵循「後進先出」原則。在程式設計、演算法與系統執行流程中，棧經常被用來管理臨時資料與呼叫次序。
